// SPDX-FileCopyrightText: 2025 Karim "nogipx" Mamatkazin <nogipx@gmail.com>
//
// SPDX-License-Identifier: LGPL-3.0-or-later

/// üéØ –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–∏–ø—ã –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è RPC –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤
///
/// –°–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç—Ä–æ–≥–∏–µ —Ç–∏–ø—ã –¥–ª—è —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ RPC API

import 'dart:async';
import 'dart:typed_data';

import 'package:rpc_dart/logger.dart';
import 'package:rpc_dart/rpc/_index.dart';

import 'rpc_service_contract.dart';

/// –û—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –≤—Å–µ—Ö RPC —Å–æ–æ–±—â–µ–Ω–∏–π - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ô!
/// –í—Å–µ —Ç–∏–ø—ã –∑–∞–ø—Ä–æ—Å–æ–≤ –∏ –æ—Ç–≤–µ—Ç–æ–≤ –¥–æ–ª–∂–Ω—ã —Ä–µ–∞–ª–∏–∑–æ–≤—ã–≤–∞—Ç—å —ç—Ç–æ—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
abstract interface class IRpcSerializableMessage {
  /// –°–µ—Ä–∏–∞–ª–∏–∑—É–µ—Ç –≤ –±–∏–Ω–∞—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ô –º–µ—Ç–æ–¥!
  /// –î–ª—è protobuf —Ç–∏–ø–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è writeToBuffer()
  /// –î–ª—è JSON —Ç–∏–ø–æ–≤ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å jsonEncode() -> utf8.encode()
  Uint8List toBuffer();

  /// –î–µ—Å–µ—Ä–∏–∞–ª–∏–∑—É–µ—Ç –∏–∑ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ô —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥!
  /// –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –≤ –∫–∞–∂–¥–æ–º –∫–ª–∞—Å—Å–µ –∫–∞–∫ static T fromBuffer(Uint8List bytes)
}

// ============================================
/// –í–ê–õ–ò–î–ê–¶–ò–Ø
// ============================================

/// –†–µ–∑—É–ª—å—Ç–∞—Ç –≤–∞–ª–∏–¥–∞—Ü–∏–∏
sealed class ValidationResult {
  const ValidationResult();
}

final class ValidationSuccess extends ValidationResult {
  const ValidationSuccess();
}

final class ValidationFailure extends ValidationResult {
  final List<String> errors;
  const ValidationFailure(this.errors);
}

/// ============================================
/// –¢–ò–ü–´ –ú–ï–¢–û–î–û–í –ò –ú–ï–¢–ê–î–ê–ù–ù–´–ï
/// ============================================

/// –¢–∏–ø—ã RPC –º–µ—Ç–æ–¥–æ–≤
enum RpcMethodType {
  unary,
  serverStream,
  clientStream,
  bidirectional,
}

/// –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –º–µ—Ç–æ–¥–∞
class RpcMethodMetadata {
  final Duration? timeout;
  final bool requiresAuth;
  final List<String> permissions;
  final bool cacheable;
  final Duration? cacheTimeout;
  final int? retryCount;
  final bool deprecated;
  final String? deprecationMessage;
  final String? since;
  final Map<String, dynamic> custom;

  const RpcMethodMetadata({
    this.timeout,
    this.requiresAuth = false,
    this.permissions = const [],
    this.cacheable = false,
    this.cacheTimeout,
    this.retryCount,
    this.deprecated = false,
    this.deprecationMessage,
    this.since,
    this.custom = const {},
  });

  RpcMethodMetadata copyWith({
    Duration? timeout,
    bool? requiresAuth,
    List<String>? permissions,
    bool? cacheable,
    Duration? cacheTimeout,
    int? retryCount,
    bool? deprecated,
    String? deprecationMessage,
    String? since,
    Map<String, dynamic>? custom,
  }) {
    return RpcMethodMetadata(
      timeout: timeout ?? this.timeout,
      requiresAuth: requiresAuth ?? this.requiresAuth,
      permissions: permissions ?? this.permissions,
      cacheable: cacheable ?? this.cacheable,
      cacheTimeout: cacheTimeout ?? this.cacheTimeout,
      retryCount: retryCount ?? this.retryCount,
      deprecated: deprecated ?? this.deprecated,
      deprecationMessage: deprecationMessage ?? this.deprecationMessage,
      since: since ?? this.since,
      custom: custom ?? this.custom,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (timeout != null) 'timeout': timeout!.inMilliseconds,
      'requiresAuth': requiresAuth,
      'permissions': permissions,
      'cacheable': cacheable,
      if (cacheTimeout != null) 'cacheTimeout': cacheTimeout!.inMilliseconds,
      if (retryCount != null) 'retryCount': retryCount,
      'deprecated': deprecated,
      if (deprecationMessage != null) 'deprecationMessage': deprecationMessage,
      if (since != null) 'since': since,
      if (custom.isNotEmpty) 'custom': custom,
    };
  }
}

/// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –º–µ—Ç–æ–¥–∞ –≤ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–µ
class RpcMethodRegistration {
  final String name;
  final RpcMethodType type;
  final Function handler;
  final String description;
  final RpcMethodMetadata metadata;
  final Type requestType;
  final Type responseType;

  const RpcMethodRegistration({
    required this.name,
    required this.type,
    required this.handler,
    required this.description,
    required this.metadata,
    required this.requestType,
    required this.responseType,
  });
}

/// ============================================
/// –û–°–ù–û–í–ù–û–ô RPC ENDPOINT
/// ============================================

/// –û—Å–Ω–æ–≤–Ω–æ–π RPC endpoint –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–º–∏ –º–æ–¥–µ–ª—è–º–∏
final class RpcEndpoint {
  final IRpcTransport _transport;
  final Map<String, dynamic> _contracts = {};
  final Map<String, RpcMethodRegistration> _methods = {};
  final List<IRpcMiddleware> _middlewares = [];
  final String? debugLabel;
  late final RpcLogger logger;
  bool _isActive = true;

  // –°–ø–∏—Å–æ–∫ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤

  RpcEndpoint({
    required IRpcTransport transport,
    this.debugLabel,
  }) : _transport = transport {
    logger = RpcLogger('RpcEndpoint[${debugLabel ?? 'default'}]');
    logger.info('RpcEndpoint —Å–æ–∑–¥–∞–Ω');
  }

  /// –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç –∫–æ–Ω—Ç—Ä–∞–∫—Ç —Å–µ—Ä–≤–∏—Å–∞
  void registerServiceContract(RpcServiceContract contract) {
    final serviceName = contract.serviceName;

    if (_contracts.containsKey(serviceName)) {
      throw RpcException(
        '–ö–æ–Ω—Ç—Ä–∞–∫—Ç –¥–ª—è —Å–µ—Ä–≤–∏—Å–∞ $serviceName —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω',
      );
    }

    logger.info('–†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç —Å–µ—Ä–≤–∏—Å–∞: $serviceName');
    _contracts[serviceName] = contract;
    contract.setup();

    final methods = contract.methods;
    for (final entry in methods.entries) {
      final methodName = entry.key;
      final method = entry.value;
      _registerMethod(
        serviceName: serviceName,
        methodName: methodName,
        method: method,
      );
    }

    logger.info(
      '–ö–æ–Ω—Ç—Ä–∞–∫—Ç $serviceName –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω —Å ${methods.length} –º–µ—Ç–æ–¥–∞–º–∏',
    );
  }

  void _registerMethod({
    required String serviceName,
    required String methodName,
    required RpcMethodRegistration method,
  }) {
    final methodKey = '$serviceName.$methodName';
    if (_methods.containsKey(methodKey)) {
      throw RpcException('–ú–µ—Ç–æ–¥ $methodKey —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω');
    }
    _methods[methodKey] = method;
    logger.info('–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –º–µ—Ç–æ–¥: $methodKey (${method.type.name})');
  }

  void addMiddleware(IRpcMiddleware middleware) {
    _middlewares.add(middleware);
    logger.info('–î–æ–±–∞–≤–ª–µ–Ω middleware: ${middleware.runtimeType}');
  }

  /// –°–æ–∑–¥–∞–µ—Ç —É–Ω–∞—Ä–Ω—ã–π request builder
  RpcUnaryRequestBuilder unaryRequest({
    required String serviceName,
    required String methodName,
  }) {
    _validateMethodExists(serviceName, methodName, RpcMethodType.unary);
    return RpcUnaryRequestBuilder(
      endpoint: this,
      serviceName: serviceName,
      methodName: methodName,
    );
  }

  /// –°–æ–∑–¥–∞–µ—Ç server stream builder
  RpcServerStreamBuilder serverStream({
    required String serviceName,
    required String methodName,
  }) {
    _validateMethodExists(serviceName, methodName, RpcMethodType.serverStream);
    return RpcServerStreamBuilder(
      endpoint: this,
      serviceName: serviceName,
      methodName: methodName,
    );
  }

  /// –°–æ–∑–¥–∞–µ—Ç client stream builder
  RpcClientStreamBuilder clientStream({
    required String serviceName,
    required String methodName,
  }) {
    _validateMethodExists(serviceName, methodName, RpcMethodType.clientStream);
    return RpcClientStreamBuilder(
      endpoint: this,
      serviceName: serviceName,
      methodName: methodName,
    );
  }

  /// –°–æ–∑–¥–∞–µ—Ç bidirectional stream builder
  RpcBidirectionalStreamBuilder bidirectionalStream({
    required String serviceName,
    required String methodName,
  }) {
    _validateMethodExists(serviceName, methodName, RpcMethodType.bidirectional);
    return RpcBidirectionalStreamBuilder(
      endpoint: this,
      serviceName: serviceName,
      methodName: methodName,
    );
  }

  void _validateMethodExists(
      String serviceName, String methodName, RpcMethodType expectedType) {
    final methodKey = '$serviceName.$methodName';
    final method = _methods[methodKey];

    if (method == null) {
      throw RpcException('–ú–µ—Ç–æ–¥ $methodKey –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω');
    }

    if (method.type != expectedType) {
      throw RpcException(
        '–ú–µ—Ç–æ–¥ $methodKey –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ ${method.type.name}, '
        '–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è ${expectedType.name}',
      );
    }
  }

  Map<String, dynamic> get registeredContracts => Map.unmodifiable(_contracts);
  Map<String, RpcMethodRegistration> get registeredMethods =>
      Map.unmodifiable(_methods);
  bool get isActive => _isActive;
  IRpcTransport get transport => _transport;

  Future<void> close() async {
    if (!_isActive) return;

    logger.info('–ó–∞–∫—Ä—ã—Ç–∏–µ RpcEndpoint');
    _isActive = false;
    _contracts.clear();
    _methods.clear();
    _middlewares.clear();

    try {
      await _transport.close();
    } catch (e) {
      logger.warning('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞: $e');
    }

    logger.info('RpcEndpoint –∑–∞–∫—Ä—ã—Ç');
  }
}

/// ============================================
/// –ü–†–Ø–ú–û–ô –°–ï–†–ò–ê–õ–ò–ó–ê–¢–û–† –ë–ï–ó ENVELOPE
/// ============================================

/// –ü—Ä—è–º–æ–π —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–ª—è —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
/// –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞–ø—Ä—è–º—É—é —Å –±–∏–Ω–∞—Ä–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏, –±–µ–∑ JSON –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Å–ª–æ—è
class RpcBytesSerializer<T extends IRpcSerializableMessage>
    implements IRpcSerializer<T> {
  final T Function(Uint8List) _fromBuffer;

  RpcBytesSerializer({
    required T Function(Uint8List) fromBuffer,
  }) : _fromBuffer = fromBuffer;

  @override
  Uint8List serialize(T message) {
    // –ü—Ä—è–º–∞—è —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ envelope'–æ–≤ –∏ JSON
    return message.toBuffer();
  }

  @override
  T deserialize(Uint8List bytes) {
    // –ü—Ä—è–º–∞—è –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON
    return _fromBuffer(bytes);
  }
}

/// ============================================
/// BUILDERS –î–õ–Ø –¢–ò–ü–û–ë–ï–ó–û–ü–ê–°–ù–´–• –í–´–ó–û–í–û–í
/// ============================================

/// Builder –¥–ª—è —É–Ω–∞—Ä–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
class RpcUnaryRequestBuilder {
  final RpcEndpoint endpoint;
  final String serviceName;
  final String methodName;

  RpcUnaryRequestBuilder({
    required this.endpoint,
    required this.serviceName,
    required this.methodName,
  });

  Future<TResponse> call<TRequest extends IRpcSerializableMessage,
      TResponse extends IRpcSerializableMessage>({
    required TRequest request,
    required TResponse Function(Uint8List) responseParser,
  }) async {
    final client = UnaryClient<TRequest, TResponse>(
      transport: endpoint.transport,
      serviceName: serviceName,
      methodName: methodName,
      requestSerializer: RpcBytesSerializer<TRequest>(
        fromBuffer: (bytes) => throw UnsupportedError(
            'Request deserialization not needed on client'),
      ),
      responseSerializer: RpcBytesSerializer<TResponse>(
        fromBuffer: responseParser,
      ),
      logger: endpoint.logger,
    );

    try {
      final response = await client.call(request);
      return response;
    } finally {
      await client.close();
    }
  }
}

/// Builder –¥–ª—è —Å–µ—Ä–≤–µ—Ä–Ω—ã—Ö —Å—Ç—Ä–∏–º–æ–≤
class RpcServerStreamBuilder {
  final RpcEndpoint endpoint;
  final String serviceName;
  final String methodName;

  RpcServerStreamBuilder({
    required this.endpoint,
    required this.serviceName,
    required this.methodName,
  });

  Stream<TResponse> call<TRequest extends IRpcSerializableMessage,
      TResponse extends IRpcSerializableMessage>({
    required TRequest request,
    required TResponse Function(Uint8List) responseParser,
  }) async* {
    final client = ServerStreamClient<TRequest, TResponse>(
      transport: endpoint.transport,
      serviceName: serviceName,
      methodName: methodName,
      requestSerializer: RpcBytesSerializer<TRequest>(
        fromBuffer: (bytes) => throw UnsupportedError(
            'Request deserialization not needed on client'),
      ),
      responseSerializer: RpcBytesSerializer<TResponse>(
        fromBuffer: responseParser,
      ),
      logger: endpoint.logger,
    );

    try {
      await client.send(request);
      await for (final message in client.responses) {
        if (message.payload != null) {
          yield message.payload!;
        }
      }
    } finally {
      await client.close();
    }
  }
}

/// Builder –¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–∏—Ö —Å—Ç—Ä–∏–º–æ–≤
class RpcClientStreamBuilder {
  final RpcEndpoint endpoint;
  final String serviceName;
  final String methodName;

  RpcClientStreamBuilder({
    required this.endpoint,
    required this.serviceName,
    required this.methodName,
  });

  Future<TResponse> call<TRequest extends IRpcSerializableMessage,
      TResponse extends IRpcSerializableMessage>({
    required Stream<TRequest> requests,
    required TResponse Function(Uint8List) responseParser,
  }) async {
    final client = ClientStreamClient<TRequest, TResponse>(
      transport: endpoint.transport,
      serviceName: serviceName,
      methodName: methodName,
      requestSerializer: RpcBytesSerializer<TRequest>(
        fromBuffer: (bytes) => throw UnsupportedError(
            'Request deserialization not needed on client'),
      ),
      responseSerializer: RpcBytesSerializer<TResponse>(
        fromBuffer: responseParser,
      ),
      logger: endpoint.logger,
    );

    try {
      await for (final request in requests) {
        client.send(request);
      }
      final response = await client.finishSending();
      return response;
    } finally {
      await client.close();
    }
  }
}

/// Builder –¥–ª—è –¥–≤—É–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö —Å—Ç—Ä–∏–º–æ–≤
class RpcBidirectionalStreamBuilder {
  final RpcEndpoint endpoint;
  final String serviceName;
  final String methodName;

  RpcBidirectionalStreamBuilder({
    required this.endpoint,
    required this.serviceName,
    required this.methodName,
  });

  Stream<TResponse> call<TRequest extends IRpcSerializableMessage,
      TResponse extends IRpcSerializableMessage>({
    required Stream<TRequest> requests,
    required TResponse Function(Uint8List) responseParser,
  }) async* {
    final client = BidirectionalStreamClient<TRequest, TResponse>(
      transport: endpoint.transport,
      serviceName: serviceName,
      methodName: methodName,
      requestSerializer: RpcBytesSerializer<TRequest>(
        fromBuffer: (bytes) => throw UnsupportedError(
            'Request deserialization not needed on client'),
      ),
      responseSerializer: RpcBytesSerializer<TResponse>(
        fromBuffer: responseParser,
      ),
      logger: endpoint.logger,
    );

    try {
      unawaited(() async {
        await for (final request in requests) {
          client.send(request);
        }
        client.finishSending();
      }());

      await for (final message in client.responses) {
        if (message.payload != null) {
          yield message.payload!;
        }
      }
    } finally {
      await client.close();
    }
  }
}

/// ============================================
/// –£–¢–ò–õ–ò–¢–´ –ò –ò–°–ö–õ–Æ–ß–ï–ù–ò–Ø
/// ============================================

/// –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –¥–ª—è RpcEndpoint
class RpcException implements Exception {
  final String message;

  RpcException(this.message);

  @override
  String toString() => 'RpcException: $message';
}

/// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è middleware
abstract class IRpcMiddleware {
  Future<dynamic> processRequest(
    String serviceName,
    String methodName,
    dynamic request,
  );

  Future<dynamic> processResponse(
    String serviceName,
    String methodName,
    dynamic response,
  );
}
