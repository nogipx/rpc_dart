Спецификация gRPC
Определения ключевых терминов

RPC (Remote Procedure Call) – удалённый вызов процедуры (метода) сервиса. Клиент при этом выполняет вызов функции на сервере так, как если бы она была локальной, передавая в неё параметры и получая результат. gRPC базируется на определении сервиса с набором таких удалённых методов. Сервис и его методы определяются в интерфейсном описании (обычно в .proto-файле) как контракт RPC: набор имён методов и типов сообщений, которые они принимают и возвращают
grpc.io
grpc.io
. Такой контракт (IDL) задаёт структуру (Service, Method, Message) для межпроцессного взаимодействия.

Stub (заглушка) – клиентская часть реализации RPC. Это локальный объект, который повторяет интерфейс сервиса и скрывает детали сетевого вызова. Клиент вызывает методы stub’а, а stub автоматически сериализует параметры в сообщения, отправляет запрос серверу и десериализует ответы
grpc.io
medium.com
. Skeleton (скелет) или service implementation – серверный эквивалент stub’а: генерируемый код-обёртка, который принимает запросы, десериализует их в аргументы, вызывает реализацию метода и упаковывает ответ в сообщение
grpc.io
medium.com
. Таким образом, stub и skeleton реализуют клиентскую и серверную части контракта RPC.

Канал (Channel) – абстракция в gRPC, представляющая логическое соединение к определённому endpoint (конечной точке – адрес сервера, например host:port). Под капотом канал может состоять из одного или нескольких TCP/HTTP2 соединений. Через канал проходят множественные параллельные RPC-запросы (HTTP/2 потоки). Один канал может обслуживать множество одновременных запросов (RPC), каждый из которых выполняется в своём HTTP/2-стриме
grpc.io
. На рисунке ниже показано, что у канала могут быть многие RPC (HTTP2-потоки), а у каждого RPC может быть несколько сообщений:

Рисунок: схема gRPC‑канала – канал содержит несколько RPC (HTTP/2‑потоков), у которых по нескольку сообщений (сообщения пакуются в HTTP2‑фреймы)
grpc.io
chromium.googlesource.com
.

Endpoint – сетевая конечная точка (адрес) сервиса, к которой подключается канал. Обычно это доменное имя или IP-адрес и порт, например example.com:50051.

Service (сервис) – набор связанных методов (RPC) логически объединённых в одну сущность. В IDL сервис определяется ключевым словом service, после чего указываются имена методов и типы их запросов/ответов. Например:

service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

Имя сервиса (HelloService) участвует в формировании полного пути метода в HTTP/2 (см. ниже)
chromium.googlesource.com
.

Method (метод) – определённый удалённый метод в сервисе. Каждый метод имеет имя (например, SayHello) и специфицирует типы входного и выходного сообщений. Методы могут быть четырёх типов: Unary (один запрос – один ответ), Server Streaming (клиент один запрос, сервер отдаёт несколько сообщений ответа), Client Streaming (клиент отправляет несколько сообщений, сервер возвращает один ответ) и Bidirectional Streaming (双方 обмениваются потоками сообщений)
grpc.io
. Например:

rpc SayHello(HelloRequest) returns (HelloResponse);            // unary
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse); // серверный стрим
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse); // клиентский стрим
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse); // двунаправленный стрим

Как видно, тип стрима обозначается ключевым словом stream.

Message (сообщение) – структурированный блок данных (обычно это объект, сериализуемый в байтовый формат), передаваемый между клиентом и сервером. В gRPC по умолчанию используются Protocol Buffers для описания структуры сообщений, но при самостоятельной реализации можно использовать любой формат (JSON, BSON, собственный)
grpc.io
. Сообщение упаковывается в gRPC-фрейм с 5-байтным префиксом (см. ниже
github.com
).

Service Name (имя сервиса) и Method Name (имя метода) – строковые идентификаторы, задающие метод в формате "/<ServiceName>/<MethodName>". В HTTP/2-заголовке :path они указываются как /<ServiceName>/<MethodName>
chromium.googlesource.com
. Например, путь для вышеупомянутого SayHello из HelloService может выглядеть как /HelloService/SayHello.

Serialization (сериализация) и Deserialization (десериализация) – процесс преобразования структуры (сообщения) в последовательность байтов и обратно. Клиент перед отправкой RPC вызывает сериализацию параметров в байты, а сервер – десериализацию обратно в структуру. При ручной реализации нужно определить формат (например, JSON) и написать код serialize(msg)/deserialize(bytes) для полей сообщений.

RPC-контракт (IDL) – формальное описание API сервиса. В gRPC обычно оформляется через файлы Protocol Buffers (.proto), где указываются сервисы, методы, типы сообщений и опции (настройки) протокола. Protobuf Options – специальные опции в .proto, которые позволяют задавать дополнительные атрибуты (например, option deprecated = true, пользовательские расширения для HTTP-гейта웨я, и т.д.). При ручной реализации gRPC-стека можно проигнорировать большинство protobuf-специфичных опций, либо использовать их по своему усмотрению (например, для генерации вспомогательного кода). Главное – соблюдение контрактного соглашения между клиентом и сервером по названиям сервисов, методов и формату сообщений.
Типы методов и стриминговых взаимодействий

gRPC поддерживает четыре режима RPC: unary (1→1), server streaming (1→N), client streaming (N→1) и bidirectional streaming (N↔N). В протоколе каждый RPC соответствует одному HTTP/2-потоку. В каждом случае обмен данными происходит в следующей общей последовательности: клиент отправляет HTTP/2 HEADERS (с метаданными вызова), затем — ноль или более DATA-фреймов с сообщениями запроса, после чего клиент устанавливает флаг END_STREAM. Сервер в ответ отправляет свои HEADERS и DATA с ответами, а по завершении – TRAILERS с кодом gRPC-статуса и опциональным сообщением об ошибке. Рассмотрим подробности для каждого типа:

    Unary RPC (одиночный запрос/ответ): Клиент выполняет локальный вызов stub’а метода, что приводит к отправке HTTP/2-заголовков. Эти заголовки включают псевдо-заголовки :method = POST, :path = /<Service>/<Method>, :scheme, :authority, а также специализированные заголовки (content-type: application/grpc, te: trailers, опциональные grpc-timeout, grpc-encoding и т.д.)
    chromium.googlesource.com
    chromium.googlesource.com
    . Затем клиент упаковывает параметры вызова в одно сообщение, сериализует его и посылает DATA-фрейм с 5-байтным префиксом (1 байт флага сжатия и 4 байта длины сообщения
    github.com
    ) и устанавливает флаг END_STREAM, сигнализируя об окончании отправки. Сервер получает эти HEADERS и DATA, десериализует запрос и выполняет метод. После обработки сервер отправляет сначала свои HEADERS (статус HTTP/2 = 200, content-type: application/grpc и др.), затем DATA-фрейм с упакованным ответным сообщением, и, наконец, HTTP/2 TRAILERS с полями grpc-status (числовой код статуса) и grpc-message (опциональное описание ошибки), устанавливая END_STREAM
    chromium.googlesource.com
    chromium.googlesource.com
    . При успешном завершении grpc-status = 0 (OK); клиент после получения этих фреймов видит ответ и завершает RPC. Если на сервере произошла ошибка обработки, сервер может сразу отправить Trailers-Only (HTTP/2 HEADERS c grpc-status ≠ 0) без DATA, либо прервать поток HTTP/2-фреймом RST_STREAM
    chromium.googlesource.com
    chromium.googlesource.com
    . Клиент переводит эти коды в исключения или ошибки на стороне приложения. gRPC гарантирует сохранение порядка сообщений: ответ всегда следует за запросом клиента, а в серверном стриме сообщения идут в том же порядке, в котором были отправлены.

    Server-Streaming RPC (серверный стрим): Клиент посылает один запрос аналогично unary-режиму: HEADERS и один DATA-фрейм с запросным сообщением, после чего ставит END_STREAM. Затем сервер может отправить несколько сообщений-ответов. Последовательность: сервер шлёт начальные HEADERS (без END_STREAM), затем один или более DATA-фреймов (каждый с одним упакованным ответным сообщением). После отправки всех сообщений сервер передаёт TRAILERS с grpc-status и закрывает поток END_STREAM
    grpc.io
    chromium.googlesource.com
    . Клиент читает сообщения из потока до получения фрейма END_STREAM и затем извлекает статус. Если сервер завершился с ошибкой, он может сразу после запроса клиента отправить только TRAILERS (без сообщений) с кодом ошибки
    chromium.googlesource.com
    .

    Client-Streaming RPC (клиентский стрим): Клиент отправляет несколько сообщений запроса. Сначала он передаёт HEADERS, а затем одну за другой посылает серию DATA-фреймов (каждый с 5-байтным префиксом и телом сообщения). После завершения отправки всех сообщений клиент ставит END_STREAM. Сервер читает данные по мере поступления, может начать обработку по ходу или после получения всех запросов. После этого сервер формирует единственный ответ: он отправляет свои HEADERS, DATA c одним сообщением-ответом и затем TRAILERS с grpc-status
    grpc.io
    chromium.googlesource.com
    . Клиент получает единственное сообщение-ответ и статус, завершает вызов.

    Bidirectional-Streaming RPC (двунаправленный стрим): Клиент открывает поток: сначала HEADERS, затем может начать отправлять свои запросы в виде DATA-фреймов (и завершить поток, установив END_STREAM, когда нужно). Параллельно сервер может в любой момент отправить свои ответные сообщения: после получения HEADERS он отправляет свои HEADERS (инициализационные метаданные) и может начать рассылать DATA с ответами независимо от клиента. Поток двунаправленный и асинхронный: клиент и сервер могут читать и писать сообщения в произвольном порядке (например, «игра в пинг-понг»: клиент шлёт запрос, сервер отвечает, потом вновь клиент и т.д.)
    grpc.io
    . Сообщения в каждом направлении сохраняют порядок отправки. По завершении обмена (или при ошибке) каждая сторона закрывает свой конец потока: обычно клиент указывает END_STREAM после всех запросов, а сервер ставит END_STREAM на последний HEADERS с трейлерами после всех ответов
    chromium.googlesource.com
    chromium.googlesource.com
    . Если в процессе возникла ошибка, аналогично unary-режиму используется grpc-status в трейлерах (или RST_STREAM при критическом сбое)
    chromium.googlesource.com
    chromium.googlesource.com
    . Например, сервер может отправить grpc-status = 0 (OK) в трейлере после последнего ответа или grpc-status = 1 (CANCELLED) в случае отмены.

Во всех режимах коды статусов gRPC (grpc-status) передаются в HTTP/2 трейлерах как числовой ASCII. Код 0 означает OK, ненулевой код (1–16) указывает на ошибку (например, CANCELLED = 1, UNKNOWN = 2, INVALID_ARGUMENT = 3, DEADLINE_EXCEEDED = 4 и т.д. по списку
grpc.io
). HTTP/2 статус в основном всегда 200, если запрос был принят протоколом gRPC (иначе сервер может вернуть 4xx/5xx, что клиент переводит в внутреннюю ошибку gRPC). Важное правило: код статуса всегда передаётся в трейлерах даже при успешном выполнении RPC
chromium.googlesource.com
, поэтому клиент должен анализировать именно grpc-status из последнего фрейма заголовков с флагом END_STREAM. В случае серьёзного сбоя на уровне транспорта (например, нарушение фрейминга) могут отправляться HTTP/2 RST_STREAM с соответствующим кодом; gRPC-клиент трактует это как аварийное завершение вызова
chromium.googlesource.com
.
Потоки данных и управление ими

gRPC использует транспорт HTTP/2, который обеспечивает высокопроизводительную передачу данных. HTTP/2 работает с мультиплексированными потоками и встроенным механизмом управления потоком (flow control). Мультиплексирование означает, что по одному TCP-соединению может идти несколько параллельных HTTP/2-стримов (каждый стрим – свой RPC). Стримы идентифицируются уникальными Stream ID; границы HTTP/2-фреймов могут прерывать данные сообщений произвольно
chromium.googlesource.com
. Передача данных идёт фреймами: приём данных организуется через фреймы типа DATA, а метаданные через фреймы HEADERS/CONTINUATION. Флаг END_STREAM на фрейме определяет конец потока данных (завершение RPC в одном направлении).

Управление потоком (flow control) предотвращает переполнение приёмника. HTTP/2 использует скользящее окно (credit-based flow control): каждый получатель указывает, сколько байт он готов принять, с помощью фреймов WINDOW_UPDATE
httpwg.org
. Изменение окна позволяет реализовать обратное давление (back-pressure): если отправитель шлёт данные быстрее, чем приёмник может обрабатывать, окно приёмника истощится и отправитель будет блокирован до получения очередного WINDOW_UPDATE. gRPC автоматически взаимодействует с HTTP/2 flow-control: библиотека не возвращает управление приложению до тех пор, пока данные не помещены в буфер и не отправлены на сетевой уровень
grpc.io
. Таким образом, клиент и сервер плавно синхронизируют скорость передачи без потери данных. По умолчанию стартовый размер окна для каждого стрима и для соединения – 65535 байт
httpwg.org
, но он может быть изменён настройками HTTP/2.

Фрагментация сообщений. gRPC-сообщение может быть больше максимального размера одного HTTP/2 DATA-фрейма. Поэтому оно разбивается на несколько фреймов: DATA frame boundaries have no relation to gRPC message boundaries
chromium.googlesource.com
. Клиент или сервер читают фреймы последовательно, собирая из них полное сообщение (по информации в 5-байтном префиксе). При передаче больших сообщений каждая часть передаётся очередным DATA-фреймом, пока не будет отправлено все байты. Аналогично, если сообщение очень большое, реализатор может посылать его частями (фрагменты).

HTTP/2 framing и заголовки. Все gRPC-вызовы идут через HTTP/2 с POST-запросом. Важные псевдо-заголовки: :method = POST, :scheme = http/https, :path = /Service/Method, :authority = host. Далее идут обычные заголовки: content-type: application/grpc, te: trailers (чтобы разрешить трейлеры), grpc-encoding/grpc-accept-encoding (алгоритмы компрессии), user-agent и др.
chromium.googlesource.com
chromium.googlesource.com
. HTTP/2 сжимает заголовки (HPACK) и передаёт их бинарно. gRPC-респонсы возвращают на HTTP/2-уровне статус :status = 200 и свои заголовки, а специфичные gRPC-поля (grpc-status и др.) идут уже в HEADERS трейлерах. Таким образом, граничный обмен выглядит так:

Клиент -> Сервер:
  HEADERS :method=POST, :path=/Service/Method, content-type=application/grpc, te=trailers, ...
  DATA (END_STREAM): <Length-Prefixed Request>

Сервер -> Клиент:
  HEADERS :status=200, content-type=application/grpc, ...
  DATA: <Length-Prefixed Response(s)>
  HEADERS (END_STREAM): grpc-status=<code>, grpc-message=<text>  (trailers)

где каждое сообщение обернуто в «length-prefixed» кадр
github.com
, а grpc-status передаётся всегда в последнем HEADERS (трейлере)
chromium.googlesource.com
.
Middleware и интерсепторы

gRPC позволяет внедрять перехватчики (interceptors) или middleware – код, выполняющийся до и/или после основной логики RPC. Перехватчики применяются и на стороне клиента, и на стороне сервера и служат для кросс-сеченных задач (logging, проверка аутентификации, трассировка, метрики и т.д.)
grpc.io
grpc.io
. Например, перехватчик на сервере может извлекать авторизационные данные из метаданных и проверять токен перед вызовом метода; клиентский перехватчик может записывать статистику по каждому вызову или добавлять заголовки (metadata) ко всем запросам.

Реализация middleware обычно оформляется как цепочка функций-обёрток. Перед выполнением метода вызывается цепочка перехватчиков, каждый из которых может изменить контекст вызова (метаданные, deadline и т.д.), зарегистрировать информацию (лог, трассировку) или даже прервать вызов, вернув ошибку. После выполнения метода цепочка прерывается, и аналогичные перехватчики (или те же в обратном порядке) обрабатывают ответ и статус. Пример псевдокода серверного перехватчика:

func LoggingInterceptor(ctx, req, handler) {
    log("Запрос в метод", ctx.methodName, "с параметрами", req)
    resp = handler(ctx, req)  // вызов следующего перехватчика или метода
    log("Ответ из метода", ctx.methodName, "со статусом", resp.statusCode)
    return resp
}

Таким образом, при ручной реализации можно добавить точки входа вокруг отправки/приёма метаданных и сообщений, чтобы реализовать нужные middleware. Шаблоны и библиотеки с уже готовыми перехватчиками (логирование, интеграции OpenTelemetry, валидация JWT и пр.) широко распространены
grpc.io
.
Гайд по ручной реализации gRPC-стека

Ниже описан общий план реализации gRPC-подобного стека «с нуля» без использования protoc или существующих фреймворков:

    Абстрактное описание контракта. Необходимо явно описать сервисы, методы и типы сообщений. Можно создать собственное представление IDL, например в виде JSON-спецификации или классов/интерфейсов в коде. Основные элементы:

        Интерфейс сервиса с именем (ServiceName) и методами. Для каждого метода указать его имя (MethodName), тип RPC (unary/streaming) и типы сообщений запроса и ответа.

        Типы сообщений (структуры данных) с полями. Если не использовать protobuf, можно определить JSON-схемы или классы.

        Пример (псевдо-IDL):

    service HelloService {
      rpc SayHello(HelloRequest) returns (HelloResponse);
      rpc Chat(stream ChatMessage) returns (stream ChatMessage);
    }
    message HelloRequest { string name; }
    message HelloResponse { string reply; }
    message ChatMessage { string from; string text; }

В коде это можно представить как словарь: contract["HelloService"]["SayHello"] = {requestType: HelloRequest, responseType: HelloResponse, mode: "unary"} и т.д.

Сериализация/десериализация. Выберите формат сериализации. Например, JSON:

    Для запроса/ответа используйте JSON.stringify(obj) и JSON.parse(bytes) (или аналогичный механизм).

    В случае бинари-формата (например, BSON или собственный) реализуйте encode/decode.

    Для каждого сообщения перед отправкой формируйте «message frame» с 5-байтным префиксом: первый байт – флаг компрессии (0 = нет), следующие 4 байта – размер сообщения (big-endian)
    github.com
    . Например:

    function encodeMessage(msgBytes) {
        // msgBytes – байты от serialize(msg)
        var compressed = false;
        var flag = compressed ? 1 : 0;
        var length = msgBytes.length;
        var header = [flag] + intToBytes(length, 4);
        return header + msgBytes;
    }

    При приёме снимайте 5-байтный заголовок, определяйте длину и флаг, затем считывайте указанное число байт и декодируйте в объект.

Устройство HTTP/2-соединения. Соединитесь с сервером по TCP (с TLS, если нужно) и выполните рукопожатие HTTP/2 (обмен SETTINGS, получение SETTINGS и т.д.). После установки канала:

    Отправка HEADERS (клиент→сервер): создайте HTTP/2-HEADERS для нового стрима:

    :method = POST
    :scheme = http (или https)
    :authority = <host>
    :path = /<ServiceName>/<MethodName>
    content-type = application/grpc+proto (или +json)
    te = trailers
    grpc-encoding = identity
    user-agent = <your-client-version>
    (опционально) grpc-timeout = "5S"

    Используйте фрейм HEADERS (+ CONTINUATION при необходимости для больших заголовков). Заголовок grpc-message-type можно опустить, если у вас один тип на метод.

    Принятие запросов (сервер): серверный код читает HEADERS, извлекает служебные поля (:path определяет сервис/метод, остальные заголовки – метаданные). Проверьте content-type (должен начинаться с application/grpc). Затем сервер может сразу отправить свои HEADERS с начальным статусом HTTP/2 (обычно :status = 200) и, если нужно, initial metadata (примерно как заголовки без END_STREAM).

    Обмен DATA-фреймами: после начальных HEADERS клиент и сервер обмениваются DATA. Запрос клиента начинается с одного или более DATA-фреймов, содержащих закодированные сообщения (см. пункт 2). В конце своей части каждый отправитель ставит END_STREAM на последний отправляемый DATA.

Реализация 4 типов RPC. Напишите код, обрабатывающий обмен данными для каждого режима:

    Unary RPC (1→1). Клиент: после отправки HEADERS выполнить sendData(encodeMessage(request)) и закрыть поток (END_STREAM). Затем ждать ответа: принимать HEADERS от сервера, потом DATA с одним сообщением, потом HEADERS (трейлеры). Распарсить ответ и статус. Сервер: после приёма клиентских HEADERS и DATA сформировать ответ: десериализовать запрос, выполнить метод, сериализовать результат. Отправить свои HEADERS (например, grpc-encoding, content-type), затем DATA с encodeMessage(response), затем HEADERS-трейлер с grpc-status=0. Если ошибка, сразу отправить HEADERS-трейлер с grpc-status=<код>.

    Server-Streaming (1→N). Клиент: отправляет HEADERS и один DATA (как unary), затем END_STREAM. Затем считывает: получает HEADERS от сервера, затем несколько DATA (каждый со своим ответным сообщением) до флага END_STREAM на трейлере. Сервер: после запроса выполняет метод и по мере готовности отправляет несколько ответов: для каждого ответа делает sendData(encodeMessage(nextMsg)). В конце отправляет HEADERS-трейлер с grpc-status=0. Если нужно прервать при ошибке – трейлер с ошибкой.

    Client-Streaming (N→1). Клиент: отправляет HEADERS, затем несколько DATA с запросами, например в цикле:

for each msg in messages:
    sendData(encodeMessage(msg))
endStream()  // установить END_STREAM на последнем DATA

Затем читает один ответ: HEADERS (с сервера), DATA (ответ) и трейлер. Сервер: приём запросов: читает последовательность сообщений (можно в цикле вызывать recvData() до конца). После получения всех вызывается обработчик, который возвращает единичный ответ. Сервер шлёт HEADERS, DATA с ответом и HEADERS-трейлер grpc-status=0.

Bidirectional-Streaming (N↔N). Оба направления независимы. Клиент: отправляет HEADERS, затем может одновременно писать запросы и читать ответы. Типичная реализация – два потока или неблокирующий цикл: один метод читает входящие DATA (и преобразует их), другой отправляет запросы аналогично client-streaming. Сервер симметрично: после HEADERS читает поток сообщений и отправляет поток ответов в произвольном порядке. В коде это может выглядеть так:

    // Клиент
    sendHeaders(...)
    параллельно:
        for msg in outgoingMessages:
            sendData(encodeMessage(msg))
        endStream()
    while not end_of_stream:
        hdrs = await headers_from_server()
        resp = decodeMessage(await data_from_server())
        process(resp)
    // Сюда придёт HEADERS-трейлер с grpc-status

    Сервер делает аналогично, отвечая на полученные запросы. В обоих случаях ключ – следить за флагами END_STREAM и корректно ставить grpc-status при завершении.

Обработка ошибок, статус-коды, разрывы соединения. Любая сторона может прервать RPC с ошибкой. В ручном стеке сервер при ошибке должен отправить HTTP/2 HEADERS-трейлер с grpc-status=<код>, где код соответствует списку gRPC (например, 13 для INTERNAL, 14 для UNAVAILABLE)
grpc.io
, и опционально grpc-message с описанием. Такой трейлер должен иметь флаг END_STREAM. Клиент при получении ненулевого grpc-status считает RPC проваленным. Если ошибка критическая (нарушение протокола), сторона может отправить RST_STREAM, и другую сторону следует трактовать вызов как ошибочный
chromium.googlesource.com
. После ошибки соединение HTTP/2 обычно закрывается или Stream переходит в состояние closed. Код статуса grpc-status=0 означает успешное завершение, любое другое – ошибку, которую надо обработать приложению. Также, если во время RPC клиент превысил deadline, он может самостоятельно послать grpc-status = 4 (DEADLINE_EXCEEDED) в трейлере и разорвать поток.

Примеры псевдокода. Ниже приведены фрагменты, иллюстрирующие основные этапы.

Отправка Unary-запроса (клиент):

// 1. Формируем и отправляем заголовки (начальное HEADERS)
sendHeaders({
    ":method": "POST",
    ":path": "/HelloService/SayHello",
    ":scheme": "http",
    ":authority": "example.com",
    "content-type": "application/grpc+proto",
    "te": "trailers",
    "grpc-encoding": "identity"
})
// 2. Сериализуем запрос и отправляем DATA с флагом END_STREAM
data = serialize({ name: "Alice" })         // JSON/BSON/другой формат
frame = encodeMessage(data)                // 5-байтная длина + data
sendData(frame, endStream = true)

// 3. Получаем ответ
responseHeaders = await recvHeaders()       // получает HEADERS от сервера
responseData = await recvData()            // DATA-фрейм с ответом
responseMsg = deserialize(responseData)    // структура HelloResponse
trailers = await recvHeaders()             // получаем трейлеры (grpc-status)
if trailers["grpc-status"] != "0":
    throw Error("RPC error " + trailers["grpc-message"])
return responseMsg

Обработка Unary-запроса (сервер):

onHeaders = await recvHeaders()
// ... проверяем аутентификацию из onHeaders["authorization"] ...
requestData = await recvData()             // получаем DATA от клиента
requestMsg = deserialize(requestData)      // разбираем HelloRequest
// Вызываем реальную логику
result = HelloService.SayHello(requestMsg)
// Отправляем ответ
sendHeaders({ ":status": 200, "content-type": "application/grpc" })
responseFrame = encodeMessage(serialize(result))
sendData(responseFrame, endStream = false)
// Завершаем вызов трейлерами
sendHeaders({ "grpc-status": "0" }, endStream = true)

Клиентский стрим (пример отправки нескольких запросов):

sendHeaders({ ... }) 
for req in arrayOfRequests:
    frame = encodeMessage(serialize(req))
    sendData(frame, endStream = false)
// закончили отправлять запросы:
sendData(null, endStream = true) // пустой DATA с END_STREAM
// ждём единичного ответа от сервера:
recvHeaders()
respData = await recvData()
resp = deserialize(respData)
recvHeaders() // трейлеры

Серверный стрим (пример отправки нескольких ответов):

// После приёма единственного запроса:
request = deserialize(await recvData())
// Генерируем несколько ответов
sendHeaders({ ":status": 200, "content-type": "application/grpc" })
for each msg in generateResponses(request):
    frame = encodeMessage(serialize(msg))
    sendData(frame, endStream = false)
// Отправляем трейлеры:
sendHeaders({ "grpc-status": "0" }, endStream = true)

Bidirectional Streaming (фрагмент):

    // Клиент начинает RPC
    sendHeaders({ ... })
    // Отправка запросов:
    spawn thread ClientWriter:
        for req in clientMessages:
            sendData(encodeMessage(serialize(req)), endStream = false)
        sendData(null, endStream = true)
    // Получение ответов:
    while true:
        hdrs = await recvHeaders()
        if hdrs contains "grpc-status":
            // трейлеры получены → конец
            break
        data = await recvData()
        if data:
            msg = deserialize(data)
            handleServerMessage(msg)

Эти примеры демонстрируют базовый механизм обмена. В реальной реализации нужно учесть все детали HTTP/2 (управление окнами, перекодирование заголовков HPACK, параллельность потоков) и правильно реагировать на исключения. Но общая структура – именно такая: установка соединения HTTP/2, обмен HEADERS, кодирование/декодирование сообщений и использование трейлеров для статусов
chromium.googlesource.com
chromium.googlesource.com
.